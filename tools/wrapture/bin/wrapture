#!/usr/bin/env ruby

require 'yaml'
#require 'wrapture'

spec = YAML::load_file ARGV[0]

spec['classes'].each do |class_spec|

  class_name = class_spec['name']
  struct_name = class_spec['equivalent-struct']['name']

  # generating constructor signatures
  members = Array.new
  class_spec['equivalent-struct']['members'].each do |member|
    members << "#{member['type']} #{member['name']}"
  end
  constructor_signature = "#{class_name}( #{members.join ', '} )"

  # generate the header file
  File.open("#{class_name}.hpp", 'w') do |file|
    # header guard
    file.puts "#ifndef __#{class_name.upcase}_HPP"
    file.puts "#define __#{class_name.upcase}_HPP"

    file.puts # line between header guard and includes

    class_spec['equivalent-struct']['includes'].each do |include_file|
      file.puts "#include <#{include_file}>"
    end

    file.puts # line between includes and namespace

    file.puts "namespace #{class_spec['namespace']} {"
    file.puts "  class #{class_name} {"
    file.puts "    private:"
    file.puts "      struct #{struct_name} equivalent;"

    file.puts # line between private and public

    file.puts "    public:"
    file.puts "      #{constructor_signature};"
    file.puts "      #{class_name}( struct #{struct_name} equivalent );"
    file.puts "      #{class_name}( const struct #{struct_name} *equivalent );"

    class_spec['equivalent-struct']['members'].each do |member|
      file.puts "      #{member['type']} Get#{member['name'].capitalize}( void ) const;"
      file.puts "      void Set#{member['name'].capitalize}( #{member['type']} #{member['name']} );"
    end

    class_spec['functions'].each do |function_spec|
      static_modifier = if function_spec['static'] then 'static ' else '' end
      file.puts "      #{static_modifier}#{function_spec['return']} #{function_spec['name']}( void );"
    end

    file.puts '  };' # end of class
    file.puts '}' # end of namespace
    file.puts '#endif' # end of header guard
  end
  
  # get the complete list of includes for definitions
  definition_includes = Array.new
  definition_includes << "#{class_name}.hpp"
  class_spec['functions'].each do |function_spec|
    definition_includes.concat function_spec['wrapped_function']['includes']
  end
  definition_includes.uniq!

  # generate the definition file
  File.open("#{class_name}.cpp", 'w') do |file|
    definition_includes.each do |include_file|
      file.puts "#include <#{include_file}>"
    end

    file.puts # line between includes and namespace

    file.puts "namespace #{class_spec['namespace']} {"

    file.puts "  #{class_name}::#{constructor_signature} {"
    class_spec['equivalent-struct']['members'].each do |member|
      file.puts "    this->equivalent.#{member['name']} = #{member['name']};"
    end
    file.puts '  }' # end of the constructor

    file.puts # line between basic constructor and struct conversion

    file.puts "  #{class_name}::#{class_name}( struct #{struct_name} equivalent ) {"
    class_spec['equivalent-struct']['members'].each do |member|
      file.puts "    this->equivalent.#{member['name']} = equivalent.#{member['name']};"
    end
    file.puts '  }' # end of struct conversion

    file.puts # line between struct conversion and pointer conversion

    file.puts "  #{class_name}::#{class_name}( const struct #{struct_name} *equivalent ) {"
    class_spec['equivalent-struct']['members'].each do |member|
      file.puts "    this->equivalent.#{member['name']} = equivalent->#{member['name']};"
    end
    file.puts '  }' # end of pointer conversion

    class_spec['equivalent-struct']['members'].each do |member|
      file.puts # line to separate from previous functions
      file.puts "  #{member['type']} #{class_name}::Get#{member['name'].capitalize}( void ) const {"
      file.puts "    return this->equivalent.#{member['name']};"
      file.puts '  }'
      file.puts
      file.puts "  void #{class_name}::Set#{member['name'].capitalize}( #{member['type']} #{member['name']} ) {"
      file.puts "    this->equivalent.#{member['name']} = #{member['name']};"
      file.puts '  }'
    end

    class_spec['functions'].each do |function_spec|
      file.puts # line to separate from previous functions
      static_modifier = if function_spec['static'] then 'static ' else '' end
      file.puts "  #{static_modifier}#{function_spec['return']} #{function_spec['name']}( void ) {"
      if function_spec['return'] == class_name
        file.puts "    return #{class_name}( #{function_spec['wrapped_function']['name']}(  ) );"
      else
        file.puts "    return #{function_spec['wrapped_function']['name']}(  );"
      end
      file.puts '  }'
    end

    file.puts # line after last function
    file.puts '}' # end of namespace
  end
end
