<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stumpless: entry.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">stumpless
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">entry.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="config_8h_source.html">stumpless/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="element_8h_source.html">stumpless/element.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="facility_8h_source.html">stumpless/facility.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="id_8h_source.html">stumpless/id.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="param_8h_source.html">stumpless/param.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="severity_8h_source.html">stumpless/severity.h</a>&gt;</code><br />
</div>
<p><a href="entry_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstumpless__entry.html">stumpless_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A log entry.  <a href="structstumpless__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3f557e1003ac224d122c999703cfe39"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ae3f557e1003ac224d122c999703cfe39">stumpless_add_element</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:ae3f557e1003ac224d122c999703cfe39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to an entry.  <a href="entry_8h.html#ae3f557e1003ac224d122c999703cfe39">More...</a><br /></td></tr>
<tr class="separator:ae3f557e1003ac224d122c999703cfe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65babe624e462794c910f23821567b65"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a65babe624e462794c910f23821567b65">stumpless_add_new_element</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *name)</td></tr>
<tr class="memdesc:a65babe624e462794c910f23821567b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element with the given name and adds it to this entry.  <a href="entry_8h.html#a65babe624e462794c910f23821567b65">More...</a><br /></td></tr>
<tr class="separator:a65babe624e462794c910f23821567b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77245510773f826dd714bf45b7f39a5d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a77245510773f826dd714bf45b7f39a5d">stumpless_add_new_param_to_entry</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *element_name, const char *param_name, const char *param_value)</td></tr>
<tr class="memdesc:a77245510773f826dd714bf45b7f39a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new param and adds it to the given element in the given entry.  <a href="entry_8h.html#a77245510773f826dd714bf45b7f39a5d">More...</a><br /></td></tr>
<tr class="separator:a77245510773f826dd714bf45b7f39a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f2be65bcbb19608c3fc00fe3c52c49"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ae2f2be65bcbb19608c3fc00fe3c52c49">stumpless_copy_entry</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:ae2f2be65bcbb19608c3fc00fe3c52c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of an entry.  <a href="entry_8h.html#ae2f2be65bcbb19608c3fc00fe3c52c49">More...</a><br /></td></tr>
<tr class="separator:ae2f2be65bcbb19608c3fc00fe3c52c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2aa7037104cf77afe2a5ee8617d26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a8a2aa7037104cf77afe2a5ee8617d26f">stumpless_destroy_entry</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a8a2aa7037104cf77afe2a5ee8617d26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for stumpless_destroy_entry_and_contents.  <a href="entry_8h.html#a8a2aa7037104cf77afe2a5ee8617d26f">More...</a><br /></td></tr>
<tr class="separator:a8a2aa7037104cf77afe2a5ee8617d26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d65cc3149e2162b7824bf190825f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ab7d65cc3149e2162b7824bf190825f7d">stumpless_destroy_entry_and_contents</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:ab7d65cc3149e2162b7824bf190825f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an entry as well as all elements and params that it contains, freeing any allocated memory.  <a href="entry_8h.html#ab7d65cc3149e2162b7824bf190825f7d">More...</a><br /></td></tr>
<tr class="separator:ab7d65cc3149e2162b7824bf190825f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454dc149ffd4206f978dcce2b6e81fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a454dc149ffd4206f978dcce2b6e81fa7">stumpless_destroy_entry_only</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a454dc149ffd4206f978dcce2b6e81fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an entry, freeing any allocated memory.  <a href="entry_8h.html#a454dc149ffd4206f978dcce2b6e81fa7">More...</a><br /></td></tr>
<tr class="separator:a454dc149ffd4206f978dcce2b6e81fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694454f9cca66faa009dfc969cc42e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a694454f9cca66faa009dfc969cc42e47">stumpless_entry_has_element</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *name)</td></tr>
<tr class="memdesc:a694454f9cca66faa009dfc969cc42e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the given entry has an element with the given name, false otherwise.  <a href="entry_8h.html#a694454f9cca66faa009dfc969cc42e47">More...</a><br /></td></tr>
<tr class="separator:a694454f9cca66faa009dfc969cc42e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af354e501ef97dda7fc73db185c0eddfc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#af354e501ef97dda7fc73db185c0eddfc">stumpless_get_element_by_index</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t index)</td></tr>
<tr class="memdesc:af354e501ef97dda7fc73db185c0eddfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in this Entry.  <a href="entry_8h.html#af354e501ef97dda7fc73db185c0eddfc">More...</a><br /></td></tr>
<tr class="separator:af354e501ef97dda7fc73db185c0eddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeedbc754cf23dba74b5db10e2158d29"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#abeedbc754cf23dba74b5db10e2158d29">stumpless_get_element_by_name</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *name)</td></tr>
<tr class="memdesc:abeedbc754cf23dba74b5db10e2158d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with the given name in this entry, if it is found.  <a href="entry_8h.html#abeedbc754cf23dba74b5db10e2158d29">More...</a><br /></td></tr>
<tr class="separator:abeedbc754cf23dba74b5db10e2158d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766eda98fe253461af4eb700277c5622"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a766eda98fe253461af4eb700277c5622">stumpless_get_element_count</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a766eda98fe253461af4eb700277c5622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the given entry.  <a href="entry_8h.html#a766eda98fe253461af4eb700277c5622">More...</a><br /></td></tr>
<tr class="separator:a766eda98fe253461af4eb700277c5622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d247f4d57a5ad86c9f289bf816afa88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a4d247f4d57a5ad86c9f289bf816afa88">stumpless_get_element_index</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *name)</td></tr>
<tr class="memdesc:a4d247f4d57a5ad86c9f289bf816afa88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element with the given name in this entry, if it is found.  <a href="entry_8h.html#a4d247f4d57a5ad86c9f289bf816afa88">More...</a><br /></td></tr>
<tr class="separator:a4d247f4d57a5ad86c9f289bf816afa88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfac0e81595f4440f6ef7fea9a56b4c6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#abfac0e81595f4440f6ef7fea9a56b4c6">stumpless_get_entry_app_name</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:abfac0e81595f4440f6ef7fea9a56b4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the app name of the given entry.  <a href="entry_8h.html#abfac0e81595f4440f6ef7fea9a56b4c6">More...</a><br /></td></tr>
<tr class="separator:abfac0e81595f4440f6ef7fea9a56b4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a1317595f54abbb74cf64dc74cfff"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a222a1317595f54abbb74cf64dc74cfff">stumpless_get_entry_facility</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a222a1317595f54abbb74cf64dc74cfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the facility code of the given entry.  <a href="entry_8h.html#a222a1317595f54abbb74cf64dc74cfff">More...</a><br /></td></tr>
<tr class="separator:a222a1317595f54abbb74cf64dc74cfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b192be58a0ce56e301da9195f5fa15"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ae3b192be58a0ce56e301da9195f5fa15">stumpless_get_entry_message</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:ae3b192be58a0ce56e301da9195f5fa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the message of the given entry.  <a href="entry_8h.html#ae3b192be58a0ce56e301da9195f5fa15">More...</a><br /></td></tr>
<tr class="separator:ae3b192be58a0ce56e301da9195f5fa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a2ae7cc0c85ffb39728fa51e5d083a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a43a2ae7cc0c85ffb39728fa51e5d083a">stumpless_get_entry_msgid</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a43a2ae7cc0c85ffb39728fa51e5d083a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the msgid of the given entry.  <a href="entry_8h.html#a43a2ae7cc0c85ffb39728fa51e5d083a">More...</a><br /></td></tr>
<tr class="separator:a43a2ae7cc0c85ffb39728fa51e5d083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb92535ef22159a446257f9e783f9215"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#adb92535ef22159a446257f9e783f9215">stumpless_get_entry_param_by_index</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, size_t param_index)</td></tr>
<tr class="memdesc:adb92535ef22159a446257f9e783f9215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the param from the element at the given index in an entry.  <a href="entry_8h.html#adb92535ef22159a446257f9e783f9215">More...</a><br /></td></tr>
<tr class="separator:adb92535ef22159a446257f9e783f9215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac480c84954ee7e025302ff4bf2ef78"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a4ac480c84954ee7e025302ff4bf2ef78">stumpless_get_entry_param_by_name</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *element_name, const char *param_name)</td></tr>
<tr class="memdesc:a4ac480c84954ee7e025302ff4bf2ef78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the first param from the element with the given name in an entry.  <a href="entry_8h.html#a4ac480c84954ee7e025302ff4bf2ef78">More...</a><br /></td></tr>
<tr class="separator:a4ac480c84954ee7e025302ff4bf2ef78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a9cf879d69009f855bad26764bbd4a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#af1a9cf879d69009f855bad26764bbd4a">stumpless_get_entry_param_value_by_index</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, size_t param_index)</td></tr>
<tr class="memdesc:af1a9cf879d69009f855bad26764bbd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of the param from the element at the given index in an entry.  <a href="entry_8h.html#af1a9cf879d69009f855bad26764bbd4a">More...</a><br /></td></tr>
<tr class="separator:af1a9cf879d69009f855bad26764bbd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cd99cc5c0ebd9e89b7024ce54161d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#aa6cd99cc5c0ebd9e89b7024ce54161d5">stumpless_get_entry_param_value_by_name</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *element_name, const char *param_name)</td></tr>
<tr class="memdesc:aa6cd99cc5c0ebd9e89b7024ce54161d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the value of the first param from the element with the given name in an entry.  <a href="entry_8h.html#aa6cd99cc5c0ebd9e89b7024ce54161d5">More...</a><br /></td></tr>
<tr class="separator:aa6cd99cc5c0ebd9e89b7024ce54161d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3907dcc7be649473944dea368ee1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a65c3907dcc7be649473944dea368ee1c">stumpless_get_entry_prival</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:a65c3907dcc7be649473944dea368ee1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prival of the given entry, as defined in RFC 5424.  <a href="entry_8h.html#a65c3907dcc7be649473944dea368ee1c">More...</a><br /></td></tr>
<tr class="separator:a65c3907dcc7be649473944dea368ee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9802c90b7297809ea2a04f68b1159fe"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ae9802c90b7297809ea2a04f68b1159fe">stumpless_get_entry_severity</a> (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry)</td></tr>
<tr class="memdesc:ae9802c90b7297809ea2a04f68b1159fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the severity code of the given entry.  <a href="entry_8h.html#ae9802c90b7297809ea2a04f68b1159fe">More...</a><br /></td></tr>
<tr class="separator:ae9802c90b7297809ea2a04f68b1159fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934ae9f97a6619e5925c0f5e2e3f25cf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a934ae9f97a6619e5925c0f5e2e3f25cf">stumpless_new_entry</a> (enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a> facility, enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a> severity, const char *app_name, const char *msgid, const char *message,...)</td></tr>
<tr class="memdesc:a934ae9f97a6619e5925c0f5e2e3f25cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry with the given characteristics.  <a href="entry_8h.html#a934ae9f97a6619e5925c0f5e2e3f25cf">More...</a><br /></td></tr>
<tr class="separator:a934ae9f97a6619e5925c0f5e2e3f25cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e4aaf1732e8092bfb557597181463"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#afc3e4aaf1732e8092bfb557597181463">stumpless_set_element</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t index, struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:afc3e4aaf1732e8092bfb557597181463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the element at the given index in the given entry.  <a href="entry_8h.html#afc3e4aaf1732e8092bfb557597181463">More...</a><br /></td></tr>
<tr class="separator:afc3e4aaf1732e8092bfb557597181463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59891c02e8081d4a7fddd00f1ff39f6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ab59891c02e8081d4a7fddd00f1ff39f6">stumpless_set_entry_app_name</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *app_name)</td></tr>
<tr class="memdesc:ab59891c02e8081d4a7fddd00f1ff39f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the app name for an entry.  <a href="entry_8h.html#ab59891c02e8081d4a7fddd00f1ff39f6">More...</a><br /></td></tr>
<tr class="separator:ab59891c02e8081d4a7fddd00f1ff39f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4de27d1ede01e5ae632c5bcc2b60ea4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#aa4de27d1ede01e5ae632c5bcc2b60ea4">stumpless_set_entry_facility</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a> facility)</td></tr>
<tr class="memdesc:aa4de27d1ede01e5ae632c5bcc2b60ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the facility of an entry.  <a href="entry_8h.html#aa4de27d1ede01e5ae632c5bcc2b60ea4">More...</a><br /></td></tr>
<tr class="separator:aa4de27d1ede01e5ae632c5bcc2b60ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2338c345676015208efb1e1cafd2d0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#afd2338c345676015208efb1e1cafd2d0">stumpless_set_entry_msgid</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *msgid)</td></tr>
<tr class="memdesc:afd2338c345676015208efb1e1cafd2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the msgid for an entry.  <a href="entry_8h.html#afd2338c345676015208efb1e1cafd2d0">More...</a><br /></td></tr>
<tr class="separator:afd2338c345676015208efb1e1cafd2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdf09e512dbfe78c66a9923cbdf306c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a6bdf09e512dbfe78c66a9923cbdf306c">stumpless_set_entry_message</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *message,...)</td></tr>
<tr class="memdesc:a6bdf09e512dbfe78c66a9923cbdf306c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message of a given entry.  <a href="entry_8h.html#a6bdf09e512dbfe78c66a9923cbdf306c">More...</a><br /></td></tr>
<tr class="separator:a6bdf09e512dbfe78c66a9923cbdf306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab66ae13eb71814f19949619b9fa77"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a0cab66ae13eb71814f19949619b9fa77">stumpless_set_entry_param_by_index</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, size_t param_index, struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *param)</td></tr>
<tr class="memdesc:a0cab66ae13eb71814f19949619b9fa77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the param in the element at the given index of an entry.  <a href="entry_8h.html#a0cab66ae13eb71814f19949619b9fa77">More...</a><br /></td></tr>
<tr class="separator:a0cab66ae13eb71814f19949619b9fa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f514991130b79f6d83813edeb0734"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ad53f514991130b79f6d83813edeb0734">stumpless_set_entry_param_value_by_index</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, size_t param_index, const char *value)</td></tr>
<tr class="memdesc:ad53f514991130b79f6d83813edeb0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the param in the element at the given index of an entry.  <a href="entry_8h.html#ad53f514991130b79f6d83813edeb0734">More...</a><br /></td></tr>
<tr class="separator:ad53f514991130b79f6d83813edeb0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01a0f9e542c2685b24d7faae5f6150"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#aca01a0f9e542c2685b24d7faae5f6150">stumpless_set_entry_param_value_by_name</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *element_name, const char *param_name, const char *value)</td></tr>
<tr class="memdesc:aca01a0f9e542c2685b24d7faae5f6150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the first param in the named element an entry.  <a href="entry_8h.html#aca01a0f9e542c2685b24d7faae5f6150">More...</a><br /></td></tr>
<tr class="separator:aca01a0f9e542c2685b24d7faae5f6150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e27125e5c340762b3ac7fd7c4a12361"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#a4e27125e5c340762b3ac7fd7c4a12361">stumpless_set_entry_priority</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a> facility, enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a> severity)</td></tr>
<tr class="memdesc:a4e27125e5c340762b3ac7fd7c4a12361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the facility and severity of an entry.  <a href="entry_8h.html#a4e27125e5c340762b3ac7fd7c4a12361">More...</a><br /></td></tr>
<tr class="separator:a4e27125e5c340762b3ac7fd7c4a12361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade045632d3f8982526026de6bc2752cc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ade045632d3f8982526026de6bc2752cc">stumpless_set_entry_prival</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, int prival)</td></tr>
<tr class="memdesc:ade045632d3f8982526026de6bc2752cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the prival of an entry, as defined in RFC 5424.  <a href="entry_8h.html#ade045632d3f8982526026de6bc2752cc">More...</a><br /></td></tr>
<tr class="separator:ade045632d3f8982526026de6bc2752cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4e3f292d98306ffed3aa58e927760d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#acf4e3f292d98306ffed3aa58e927760d">stumpless_set_entry_severity</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a> severity)</td></tr>
<tr class="memdesc:acf4e3f292d98306ffed3aa58e927760d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the severity of an entry.  <a href="entry_8h.html#acf4e3f292d98306ffed3aa58e927760d">More...</a><br /></td></tr>
<tr class="separator:acf4e3f292d98306ffed3aa58e927760d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4deee5e9bc6382a7c32d767544599a3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ad4deee5e9bc6382a7c32d767544599a3">vstumpless_new_entry</a> (enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a> facility, enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a> severity, const char *app_name, const char *msgid, const char *message, va_list subs)</td></tr>
<tr class="memdesc:ad4deee5e9bc6382a7c32d767544599a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry with the given parameters.  <a href="entry_8h.html#ad4deee5e9bc6382a7c32d767544599a3">More...</a><br /></td></tr>
<tr class="separator:ad4deee5e9bc6382a7c32d767544599a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c06b144b66a02ade646ab3c106c71d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="entry_8h.html#ae4c06b144b66a02ade646ab3c106c71d">vstumpless_set_entry_message</a> (struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, const char *message, va_list subs)</td></tr>
<tr class="memdesc:ae4c06b144b66a02ade646ab3c106c71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the message of a given entry.  <a href="entry_8h.html#ae4c06b144b66a02ade646ab3c106c71d">More...</a><br /></td></tr>
<tr class="separator:ae4c06b144b66a02ade646ab3c106c71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Types and functions for creating and modifying entries. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae3f557e1003ac224d122c999703cfe39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f557e1003ac224d122c999703cfe39">&#9670;&nbsp;</a></span>stumpless_add_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_add_element </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an element to an entry. </p>
<p>The element is appended to the end of the list of elements in this entry.</p>
<p>Note that duplicate elements are not allowed in RFC 5424, and as such attempts to add an element to an entry already having one with the same name will result in a STUMPLESS_DUPLICATE_ELEMENT error.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to add the element to.</td></tr>
    <tr><td class="paramname">element</td><td>The element to add to the entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a65babe624e462794c910f23821567b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65babe624e462794c910f23821567b65">&#9670;&nbsp;</a></span>stumpless_add_new_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_add_new_element </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element with the given name and adds it to this entry. </p>
<p>Note that duplicate elements are not allowed in RFC 5424, and as such attempts to add an element to an entry already having one with the same name will result in a STUMPLESS_DUPLICATE_ELEMENT error.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to add the new element to.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the new element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a77245510773f826dd714bf45b7f39a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77245510773f826dd714bf45b7f39a5d">&#9670;&nbsp;</a></span>stumpless_add_new_param_to_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_add_new_param_to_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new param and adds it to the given element in the given entry. </p>
<p>If an element with the given name does not exist in the given entry, then one will be created with the new param added to it.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to add the new param to.</td></tr>
    <tr><td class="paramname">element_name</td><td>The name of the element to add the param to. If an element with this name is not found, it will be created.</td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the new param to add.</td></tr>
    <tr><td class="paramname">param_value</td><td>The value of the new param to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ae2f2be65bcbb19608c3fc00fe3c52c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f2be65bcbb19608c3fc00fe3c52c49">&#9670;&nbsp;</a></span>stumpless_copy_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_copy_entry </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of an entry. </p>
<p>Copies of entries are 'deep' in that the copy also copies each of the elements that the original entry has, if any. This means that even if the elements or params of the original entry are destroyed, the equivalent ones in this entry will still be valid.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the copy.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new entry that is a deep copy of the original. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a8a2aa7037104cf77afe2a5ee8617d26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2aa7037104cf77afe2a5ee8617d26f">&#9670;&nbsp;</a></span>stumpless_destroy_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_entry </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for stumpless_destroy_entry_and_contents. </p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function has been deprecated in favor of the more descriptive and deliberate stumpless_destroy_entry_and_contents and stumpless_destroy_entry_only functions in order to avoid unintentional memory leaks and use-after-free mistakes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d65cc3149e2162b7824bf190825f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d65cc3149e2162b7824bf190825f7d">&#9670;&nbsp;</a></span>stumpless_destroy_entry_and_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_entry_and_contents </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an entry as well as all elements and params that it contains, freeing any allocated memory. </p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454dc149ffd4206f978dcce2b6e81fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454dc149ffd4206f978dcce2b6e81fa7">&#9670;&nbsp;</a></span>stumpless_destroy_entry_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_entry_only </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an entry, freeing any allocated memory. </p>
<p>Associated elements and params are left untouched, and must be destroyed separately.</p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a694454f9cca66faa009dfc969cc42e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694454f9cca66faa009dfc969cc42e47">&#9670;&nbsp;</a></span>stumpless_entry_has_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stumpless_entry_has_element </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the given entry has an element with the given name, false otherwise. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to search for the element.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the element to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if no error is encountered and the element is found. If the element is not found or an error is encountered, then false is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="af354e501ef97dda7fc73db185c0eddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af354e501ef97dda7fc73db185c0eddfc">&#9670;&nbsp;</a></span>stumpless_get_element_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a>* stumpless_get_element_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the given index in this Entry. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to search.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the element to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element if it is found in the entry, or NULL otherwise. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="abeedbc754cf23dba74b5db10e2158d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeedbc754cf23dba74b5db10e2158d29">&#9670;&nbsp;</a></span>stumpless_get_element_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a>* stumpless_get_element_by_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element with the given name in this entry, if it is found. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to search.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element if it is found in the entry, or NULL otherwise. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a766eda98fe253461af4eb700277c5622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766eda98fe253461af4eb700277c5622">&#9670;&nbsp;</a></span>stumpless_get_element_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stumpless_get_element_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of elements in the given entry. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being read.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate the read of the entry.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v2.0.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the element count of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements entry has. If there is an error, zero is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a4d247f4d57a5ad86c9f289bf816afa88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d247f4d57a5ad86c9f289bf816afa88">&#9670;&nbsp;</a></span>stumpless_get_element_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stumpless_get_element_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the element with the given name in this entry, if it is found. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to search.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the element to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the element if it is found in the entry. If an error was encountered or the element does not exist in the entry, then 0 is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="abfac0e81595f4440f6ef7fea9a56b4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfac0e81595f4440f6ef7fea9a56b4c6">&#9670;&nbsp;</a></span>stumpless_get_entry_app_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* stumpless_get_entry_app_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the app name of the given entry. </p>
<p>The character buffer returned must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the name and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the param with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the app name of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The app name of the entry if no error is encountered. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a222a1317595f54abbb74cf64dc74cfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a1317595f54abbb74cf64dc74cfff">&#9670;&nbsp;</a></span>stumpless_get_entry_facility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a> stumpless_get_entry_facility </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the facility code of the given entry. </p>
<p>In versions prior to v2.0.0, this function returned an int, and -1 in the event of an error.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being read.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate the read of the entry.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the facility of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The facility of the entry if no error is encountered. If an error was encountered, then an invalid facility is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ae3b192be58a0ce56e301da9195f5fa15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b192be58a0ce56e301da9195f5fa15">&#9670;&nbsp;</a></span>stumpless_get_entry_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* stumpless_get_entry_message </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the message of the given entry. </p>
<p>The character buffer returned must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>Note that if this message was originally set using format specifiers, the result will have them substituted, instead of the original placeholders.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the name and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the param with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the message of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message of the entry if no error is encountered. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a43a2ae7cc0c85ffb39728fa51e5d083a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a2ae7cc0c85ffb39728fa51e5d083a">&#9670;&nbsp;</a></span>stumpless_get_entry_msgid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* stumpless_get_entry_msgid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the msgid of the given entry. </p>
<p>The character buffer returned must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the name and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the param with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the msgid of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The msgid of the entry if no error is encountered. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="adb92535ef22159a446257f9e783f9215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb92535ef22159a446257f9e783f9215">&#9670;&nbsp;</a></span>stumpless_get_entry_param_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__param.html">stumpless_param</a>* stumpless_get_entry_param_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>param_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the param from the element at the given index in an entry. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the param from.</td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the element to get the param from.</td></tr>
    <tr><td class="paramname">param_index</td><td>The index of the param to get from the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The param at the given index if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a4ac480c84954ee7e025302ff4bf2ef78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac480c84954ee7e025302ff4bf2ef78">&#9670;&nbsp;</a></span>stumpless_get_entry_param_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__param.html">stumpless_param</a>* stumpless_get_entry_param_by_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the first param from the element with the given name in an entry. </p>
<p>Note that an element may contain as many instances of a param as desired according to RFC 5424, and therefore there may be other param instances with the same name. If you need a reference to other params with the same name in the element, then you must loop through all params using stumpless_get_entry_param_by_index, checking each name.</p>
<p><b>Thread Safety: MT-Safe race:element_name race:param_name</b> This function is thread safe, of course assuming that the names are not changed by another thread during execution. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the param from.</td></tr>
    <tr><td class="paramname">element_name</td><td>The name of the element to get the param from.</td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the param to get from the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first param with the given name if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="af1a9cf879d69009f855bad26764bbd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a9cf879d69009f855bad26764bbd4a">&#9670;&nbsp;</a></span>stumpless_get_entry_param_value_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* stumpless_get_entry_param_value_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>param_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of the param from the element at the given index in an entry. </p>
<p>The result character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the value and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the param from.</td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the element to get the param from.</td></tr>
    <tr><td class="paramname">param_index</td><td>The index of the param to get the value of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the param at the given index if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aa6cd99cc5c0ebd9e89b7024ce54161d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cd99cc5c0ebd9e89b7024ce54161d5">&#9670;&nbsp;</a></span>stumpless_get_entry_param_value_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* stumpless_get_entry_param_value_by_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the value of the first param from the element with the given name in an entry. </p>
<p>The result character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>Note that an element may contain as many instances of a param as desired according to RFC 5424, and therefore there may be other param instances with the same name. If you need the value of other params with the same name in the element, then you must loop through all params using stumpless_get_entry_param_by_index, checking each name.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the value and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe race:element_name race:param_name</b> This function is thread safe, of course assuming that the names are not changed by another thread during execution. A mutex is used to coordinate access to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the param from.</td></tr>
    <tr><td class="paramname">element_name</td><td>The name of the element to get the param from.</td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the param to get from the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the first param with the given name if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a65c3907dcc7be649473944dea368ee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c3907dcc7be649473944dea368ee1c">&#9670;&nbsp;</a></span>stumpless_get_entry_prival()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stumpless_get_entry_prival </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the prival of the given entry, as defined in RFC 5424. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being read.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate the read of the entry.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the prival of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The prival of the entry if no error is encountered. If an error was encountered, then -1 is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ae9802c90b7297809ea2a04f68b1159fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9802c90b7297809ea2a04f68b1159fe">&#9670;&nbsp;</a></span>stumpless_get_entry_severity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a> stumpless_get_entry_severity </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the severity code of the given entry. </p>
<p>In versions prior to v2.0.0, this function returned an int, and -1 in the event of an error.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being read.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate the read of the entry.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to get the severity of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The severity of the entry if no error is encountered. If an error was encountered, then an invalid severity is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a934ae9f97a6619e5925c0f5e2e3f25cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934ae9f97a6619e5925c0f5e2e3f25cf">&#9670;&nbsp;</a></span>stumpless_new_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_new_entry </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a>&#160;</td>
          <td class="paramname"><em>facility</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a>&#160;</td>
          <td class="paramname"><em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>app_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msgid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new entry with the given characteristics. </p>
<p>In versions prior to 2.0.0, the facility and severity parameters were int types instead of enums.</p>
<p><b>Thread Safety: MT-Safe race:app_name race:msgid race:message</b> This function is thread safe, of course assuming that the string arguments are not changed by other threads during execution.</p>
<p><b>Async Signal Safety: AS-Unsafe heap</b> This function is not safe to call from signal handlers due to the use of memory management functions to create the new element.</p>
<p><b>Async Cancel Safety: AC-Unsafe heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facility</td><td>The facility code of the event this entry describes. This should be a <code>STUMPLESS_FACILITY</code> value.</td></tr>
    <tr><td class="paramname">severity</td><td>The severity code of the event this entry describes. This should be a <code>STUMPLESS_SEVERITY</code> value.</td></tr>
    <tr><td class="paramname">app_name</td><td>The app_name of the entry. If this is NULL, then it will be blank in the entry (a single '-' character).</td></tr>
    <tr><td class="paramname">msgid</td><td>The message id of the entry. If this is NULL, then it will be blank in the entry (a single '-' character).</td></tr>
    <tr><td class="paramname">message</td><td>The message in the entry. This message may contain any format specifiers valid in <code>printf</code>. If this is NULL, then it will be blank in the entry (no characters). This also means that characters such as % need to be escaped as they would be in printf.</td></tr>
    <tr><td class="paramname">...</td><td>Substitutions for any format specifiers provided in message. The number of substitutions provided must exactly match the number of specifiers given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="afc3e4aaf1732e8092bfb557597181463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3e4aaf1732e8092bfb557597181463">&#9670;&nbsp;</a></span>stumpless_set_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_element </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the element at the given index in the given entry. </p>
<p>The element previously at this position will be removed from the entry, but it is NOT destroyed by this call. Callers must clean up this element separately.</p>
<p>An element cannot be set at an index position that does not already hold one. If this is attempted, then a STUMPLESS_INDEX_OUT_OF_BOUNDS error is raised.</p>
<p>Note that duplicate elements are not allowed in RFC 5424, and as such attempts to set an element of an entry which already contains another element with the same name will result in a STUMPLESS_DUPLICATE_ELEMENT error.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the element on.</td></tr>
    <tr><td class="paramname">index</td><td>The index to set to element.</td></tr>
    <tr><td class="paramname">element</td><td>The element to set at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ab59891c02e8081d4a7fddd00f1ff39f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59891c02e8081d4a7fddd00f1ff39f6">&#9670;&nbsp;</a></span>stumpless_set_entry_app_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_app_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>app_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the app name for an entry. </p>
<p><b>Thread Safety: MT-Safe race:app_name</b> This function is thread safe, of course assuming that the name is not changed by any other threads during execution. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions to create the new name and free the old one.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry for which the app name will be set.</td></tr>
    <tr><td class="paramname">app_name</td><td>A NULL-terminated string holding the new app_name for the entry. This will be copied in to the entry, and therefore may be modified or freed after this call without affecting the entry. If this is NULL, then a single '-' character will be used, as specified as the NILVALUE in RFC<ol type="1">
<li>The app name length is restricted to be 48 characters or less.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aa4de27d1ede01e5ae632c5bcc2b60ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4de27d1ede01e5ae632c5bcc2b60ea4">&#9670;&nbsp;</a></span>stumpless_set_entry_facility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_facility </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a>&#160;</td>
          <td class="paramname"><em>facility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the facility of an entry. </p>
<p>In versions prior to 2.0.0, the facility parameter was an int type instead of an enum.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the facility of.</td></tr>
    <tr><td class="paramname">facility</td><td>The new facility of the entry. This must be a valid value according to RFC 5424, available as STUMPLESS_FACILITY constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a6bdf09e512dbfe78c66a9923cbdf306c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdf09e512dbfe78c66a9923cbdf306c">&#9670;&nbsp;</a></span>stumpless_set_entry_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message of a given entry. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions to create the new message and free the old one.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to modify.</td></tr>
    <tr><td class="paramname">message</td><td>The new message to set on the entry. This message may contain any format specifiers valid in <code>printf</code>. If this is NULL, then it will be blank in the entry (no characters). This also means that characters such as % need to be escaped as they would be in printf.</td></tr>
    <tr><td class="paramname">...</td><td>Substitutions for any format specifiers provided in message. The number of substitutions provided must exactly match the number of specifiers given.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="afd2338c345676015208efb1e1cafd2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2338c345676015208efb1e1cafd2d0">&#9670;&nbsp;</a></span>stumpless_set_entry_msgid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_msgid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msgid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the msgid for an entry. </p>
<p><b>Thread Safety: MT-Safe race:msgid</b> This function is thread safe, of course assuming that the msgid is not changed by any other threads during execution. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions to create the new msgid and free the old one.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry for which the msgid will be set.</td></tr>
    <tr><td class="paramname">msgid</td><td>A NULL-terminated string holding the new msgid for the entry. This will be copied in to the entry, and therefore may be modified or freed after this call without affecting the entry. If this is NULL, then a single '-' character will be used, as specified as the NILVALUE in RFC 5424.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a0cab66ae13eb71814f19949619b9fa77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab66ae13eb71814f19949619b9fa77">&#9670;&nbsp;</a></span>stumpless_set_entry_param_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_param_by_index </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>param_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the param in the element at the given index of an entry. </p>
<p>The parameter previously at this position will be removed from the element, but it is NOT destroyed by this call. Callers must clean up this param separately.</p>
<p>A param cannot be set at an index position that does not already hold a param. If this is attempted, then a STUMPLESS_INDEX_OUT_OF_BOUNDS error is raised.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the param on.</td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the element to have the param.</td></tr>
    <tr><td class="paramname">param_index</td><td>The index to put the param at in the chosen element.</td></tr>
    <tr><td class="paramname">param</td><td>The param to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ad53f514991130b79f6d83813edeb0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53f514991130b79f6d83813edeb0734">&#9670;&nbsp;</a></span>stumpless_set_entry_param_value_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_param_value_by_index </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>param_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the param in the element at the given index of an entry. </p>
<p><b>Thread Safety: MT-Safe race:value</b> This function is thread safe, of course assuming that value is not changed by any other threads during execution. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the param value on.</td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the element having the param to modify.</td></tr>
    <tr><td class="paramname">param_index</td><td>The index of the param to set the value of.</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set on the param.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aca01a0f9e542c2685b24d7faae5f6150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01a0f9e542c2685b24d7faae5f6150">&#9670;&nbsp;</a></span>stumpless_set_entry_param_value_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_param_value_by_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the first param in the named element an entry. </p>
<p>If an element with the given name is not found in the entry, one is created with the supplied name and added to the end of the entry.</p>
<p>If a param of the given name is not found in the named element, one is created with the supplied name and value and added to the end of the element.</p>
<p>If you need to set the value of a param with this name other than the first one, then you will need to loop through the params using stumpless_get_entry_param_by_index to find the params you want and then set the value using stumpless_set_entry_param_value_by_index.</p>
<p><b>Thread Safety: MT-Safe race:element_name race:param_name race:value</b> This function is thread safe, of course assuming that the names and value are not changed by any other threads during execution. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the param value on.</td></tr>
    <tr><td class="paramname">element_name</td><td>The name of the element having the param to modify.</td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the param to set the value of.</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set on the param.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a4e27125e5c340762b3ac7fd7c4a12361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e27125e5c340762b3ac7fd7c4a12361">&#9670;&nbsp;</a></span>stumpless_set_entry_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_priority </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a>&#160;</td>
          <td class="paramname"><em>facility</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a>&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the facility and severity of an entry. </p>
<p>In versions prior to 2.0.0, the facility and severity parameters were int types instead of enums.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the priority values of.</td></tr>
    <tr><td class="paramname">facility</td><td>The new facility of the entry. This must be a valid value according to RFC 5424, available as STUMPLESS_FACILITY constants.</td></tr>
    <tr><td class="paramname">severity</td><td>The new severity of the entry. This must be a valid value according to RFC 5424, available as STUMPLESS_SEVERITY constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ade045632d3f8982526026de6bc2752cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade045632d3f8982526026de6bc2752cc">&#9670;&nbsp;</a></span>stumpless_set_entry_prival()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_prival </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prival</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the prival of an entry, as defined in RFC 5424. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the prival of.</td></tr>
    <tr><td class="paramname">prival</td><td>The new prival of the entry, as defined in RFC 5424. Only the first 8 bits of prival are considered: the rest are discarded after extracting the effective facility and severity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="acf4e3f292d98306ffed3aa58e927760d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4e3f292d98306ffed3aa58e927760d">&#9670;&nbsp;</a></span>stumpless_set_entry_severity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* stumpless_set_entry_severity </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a>&#160;</td>
          <td class="paramname"><em>severity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the severity of an entry. </p>
<p>In versions prior to 2.0.0, the severity parameter was an int type instead of an enum.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>Since</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to set the severity of.</td></tr>
    <tr><td class="paramname">severity</td><td>The new severity of the entry. This must be a valid value according to RFC 5424, available as STUMPLESS_SEVERITY constants.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ad4deee5e9bc6382a7c32d767544599a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4deee5e9bc6382a7c32d767544599a3">&#9670;&nbsp;</a></span>vstumpless_new_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* vstumpless_new_entry </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="facility_8h.html#ae5503160a92cd9826c0d9db53fa2d18a">stumpless_facility</a>&#160;</td>
          <td class="paramname"><em>facility</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="severity_8h.html#a5abdbd435635ff97469956113ce954d2">stumpless_severity</a>&#160;</td>
          <td class="paramname"><em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>app_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msgid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>subs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new entry with the given parameters. </p>
<p>In versions prior to 2.0.0, the facility and severity parameters were int types instead of enums.</p>
<p><b>Thread Safety: MT-Safe race:app_name race:msgid race:message</b> This function is thread safe, of course assuming that the string arguments are not changed by other threads during execution.</p>
<p><b>Async Signal Safety: AS-Unsafe heap</b> This function is not safe to call from signal handlers due to the use of memory management functions to create the new element.</p>
<p><b>Async Cancel Safety: AC-Unsafe heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facility</td><td>The facility code of the entry. This should be a <code>STUMPLESS_FACILITY</code> value.</td></tr>
    <tr><td class="paramname">severity</td><td>The severity code of the entry. This should be a <code>STUMPLESS_SEVERITY</code> value.</td></tr>
    <tr><td class="paramname">app_name</td><td>The app_name of the entry. If this is NULL, then it will be blank in the entry (a single '-' character). The app name length is restricted to be 48 characters or less.</td></tr>
    <tr><td class="paramname">msgid</td><td>The message id of the entry. If this is NULL, then it will be blank in the entry (a single '-' character).</td></tr>
    <tr><td class="paramname">message</td><td>The message in the entry. This message may contain any format specifiers valid in <code>printf</code>. If this is NULL, then it will be blank in the entry (no characters). This also means that characters such as % need to be escaped as they would be in printf.</td></tr>
    <tr><td class="paramname">subs</td><td>Substitutions for any format specifiers provided in message. The number of substitutions provided must exactly match the number of specifiers given. This list must be started via <code>va_start</code> before being used, and <code>va_end</code> should be called afterwards, as this function does not call them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ae4c06b144b66a02ade646ab3c106c71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c06b144b66a02ade646ab3c106c71d">&#9670;&nbsp;</a></span>vstumpless_set_entry_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a>* vstumpless_set_entry_message </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>subs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the message of a given entry. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the entry while it is being modified.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate changes and the use of memory management functions to create the new message and free the old one.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry to modify.</td></tr>
    <tr><td class="paramname">message</td><td>The new message to set on the entry. This message may contain any format specifiers valid in <code>printf</code>. If this is NULL, then it will be blank in the entry (no characters). Characters such as % need to be escaped as they would be in printf.</td></tr>
    <tr><td class="paramname">subs</td><td>Substitutions for any format specifiers provided in message. The number of substitutions provided must exactly match the number of specifiers given. This list must be started via <code>va_start</code> before being used, and <code>va_end</code> should be called afterwards, as this function does not call them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified entry if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 1 2021 15:43:35 for stumpless by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
