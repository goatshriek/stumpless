<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>stumpless: stumpless/element.h 文件参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">stumpless<span id="projectnumber">&#160;2.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('element_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">结构体</a> &#124;
<a href="#define-members">宏定义</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">element.h 文件参考</div></div>
</div><!--header-->
<div class="contents">

<p>Types and functions for creating and modifying elements.  
<a href="#details">更多...</a></p>

<p><a href="element_8h_source.html">浏览该文件的源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
结构体</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstumpless__element.html">stumpless_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An element of structured data.  <a href="structstumpless__element.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
宏定义</h2></td></tr>
<tr class="memitem:ada5fad826965fa8577e97395a2513ffd" id="r_ada5fad826965fa8577e97395a2513ffd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5fad826965fa8577e97395a2513ffd">STUMPLESS_MAX_ELEMENT_NAME_LENGTH</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:ada5fad826965fa8577e97395a2513ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of an element name, as specified by RFC 5424.  <br /></td></tr>
<tr class="separator:ada5fad826965fa8577e97395a2513ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:ac610c390facaa0990cae26ed645cf82e" id="r_ac610c390facaa0990cae26ed645cf82e"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac610c390facaa0990cae26ed645cf82e">stumpless_element_namer_func_t</a>) (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, char *destination, size_t size)</td></tr>
<tr class="memdesc:ac610c390facaa0990cae26ed645cf82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name to use for the journald field corresponding to this element.  <br /></td></tr>
<tr class="separator:ac610c390facaa0990cae26ed645cf82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a92b5c4af6341951dad54a9af788e2a14" id="r_a92b5c4af6341951dad54a9af788e2a14"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b5c4af6341951dad54a9af788e2a14">stumpless_add_new_param</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *param_name, const char *param_value)</td></tr>
<tr class="memdesc:a92b5c4af6341951dad54a9af788e2a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new param and adds it to the given element.  <br /></td></tr>
<tr class="separator:a92b5c4af6341951dad54a9af788e2a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b39498f3b9bd6dd20d49d5fc16a99e" id="r_a36b39498f3b9bd6dd20d49d5fc16a99e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b39498f3b9bd6dd20d49d5fc16a99e">stumpless_add_param</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *param)</td></tr>
<tr class="memdesc:a36b39498f3b9bd6dd20d49d5fc16a99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a param to an element.  <br /></td></tr>
<tr class="separator:a36b39498f3b9bd6dd20d49d5fc16a99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6b6d0c8682b7409d494850e990f2b3" id="r_acf6b6d0c8682b7409d494850e990f2b3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf6b6d0c8682b7409d494850e990f2b3">stumpless_copy_element</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:acf6b6d0c8682b7409d494850e990f2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of an element.  <br /></td></tr>
<tr class="separator:acf6b6d0c8682b7409d494850e990f2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde32c8772ca89cce0d3ee638d8ed67b" id="r_afde32c8772ca89cce0d3ee638d8ed67b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afde32c8772ca89cce0d3ee638d8ed67b">stumpless_destroy_element</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:afde32c8772ca89cce0d3ee638d8ed67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for stumpless_destroy_element_and_contents.  <br /></td></tr>
<tr class="separator:afde32c8772ca89cce0d3ee638d8ed67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3293ce2407142a896c6ece0089cac33" id="r_ab3293ce2407142a896c6ece0089cac33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3293ce2407142a896c6ece0089cac33">stumpless_destroy_element_and_contents</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *e)</td></tr>
<tr class="memdesc:ab3293ce2407142a896c6ece0089cac33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an element as well as all params that it contains, freeing any allocated memory.  <br /></td></tr>
<tr class="separator:ab3293ce2407142a896c6ece0089cac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f6e8a9f3dc18d7dbffee19627fa331" id="r_a26f6e8a9f3dc18d7dbffee19627fa331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26f6e8a9f3dc18d7dbffee19627fa331">stumpless_destroy_element_only</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:a26f6e8a9f3dc18d7dbffee19627fa331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an element, freeing any allocated memory.  <br /></td></tr>
<tr class="separator:a26f6e8a9f3dc18d7dbffee19627fa331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a1a0eaf93f5026f91824ff1292e71f" id="r_a96a1a0eaf93f5026f91824ff1292e71f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a1a0eaf93f5026f91824ff1292e71f">stumpless_element_has_param</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:a96a1a0eaf93f5026f91824ff1292e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the given element has a param with the given name, false otherwise.  <br /></td></tr>
<tr class="separator:a96a1a0eaf93f5026f91824ff1292e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76334de05ecec6302acdd2b368c4dda" id="r_af76334de05ecec6302acdd2b368c4dda"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af76334de05ecec6302acdd2b368c4dda">stumpless_element_to_string</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:af76334de05ecec6302acdd2b368c4dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name and params from element as a formatted string.  <br /></td></tr>
<tr class="separator:af76334de05ecec6302acdd2b368c4dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ad7dc6eb77d8beced2b0ce9462d159" id="r_aa6ad7dc6eb77d8beced2b0ce9462d159"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6ad7dc6eb77d8beced2b0ce9462d159">stumpless_get_element_name</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:aa6ad7dc6eb77d8beced2b0ce9462d159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the given element.  <br /></td></tr>
<tr class="separator:aa6ad7dc6eb77d8beced2b0ce9462d159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0171fc80fbf9f4fa0e7ecae07bf93213" id="r_a0171fc80fbf9f4fa0e7ecae07bf93213"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0171fc80fbf9f4fa0e7ecae07bf93213">stumpless_get_param_by_index</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, size_t index)</td></tr>
<tr class="memdesc:a0171fc80fbf9f4fa0e7ecae07bf93213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the param in the given element at the specified index.  <br /></td></tr>
<tr class="separator:a0171fc80fbf9f4fa0e7ecae07bf93213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a45b3e8de00bf01ae382b30bdc708d" id="r_a68a45b3e8de00bf01ae382b30bdc708d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a45b3e8de00bf01ae382b30bdc708d">stumpless_get_param_by_name</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:a68a45b3e8de00bf01ae382b30bdc708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first occurrence of a param with the given name in element, if it is found.  <br /></td></tr>
<tr class="separator:a68a45b3e8de00bf01ae382b30bdc708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792f240cdec230073975f0e890a7cd80" id="r_a792f240cdec230073975f0e890a7cd80"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792f240cdec230073975f0e890a7cd80">stumpless_get_param_count</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:a792f240cdec230073975f0e890a7cd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of params in the given element.  <br /></td></tr>
<tr class="separator:a792f240cdec230073975f0e890a7cd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcc1fbe4d13fdcab7d7a16997f99b10" id="r_a8fcc1fbe4d13fdcab7d7a16997f99b10"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fcc1fbe4d13fdcab7d7a16997f99b10">stumpless_get_param_index</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:a8fcc1fbe4d13fdcab7d7a16997f99b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the index of the first occurrence of a param with the given name in the given element.  <br /></td></tr>
<tr class="separator:a8fcc1fbe4d13fdcab7d7a16997f99b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1a7539ed5de4453534a56ee47076e" id="r_a6da1a7539ed5de4453534a56ee47076e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da1a7539ed5de4453534a56ee47076e">stumpless_get_param_name_by_index</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, size_t index)</td></tr>
<tr class="memdesc:a6da1a7539ed5de4453534a56ee47076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the param with the given index in this element.  <br /></td></tr>
<tr class="separator:a6da1a7539ed5de4453534a56ee47076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61ef0406ba4d283baa8b2d7dc324779" id="r_ae61ef0406ba4d283baa8b2d7dc324779"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61ef0406ba4d283baa8b2d7dc324779">stumpless_get_param_name_count</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:ae61ef0406ba4d283baa8b2d7dc324779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the number of params with the given name found in the given element.  <br /></td></tr>
<tr class="separator:ae61ef0406ba4d283baa8b2d7dc324779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac026aa615608e7de8c72b1d34f966fdc" id="r_ac026aa615608e7de8c72b1d34f966fdc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac026aa615608e7de8c72b1d34f966fdc">stumpless_get_param_value_by_index</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, size_t index)</td></tr>
<tr class="memdesc:ac026aa615608e7de8c72b1d34f966fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the param at the given index in the given element.  <br /></td></tr>
<tr class="separator:ac026aa615608e7de8c72b1d34f966fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ace76e27d8128316d1f202b61317d5b" id="r_a5ace76e27d8128316d1f202b61317d5b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ace76e27d8128316d1f202b61317d5b">stumpless_get_param_value_by_name</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:a5ace76e27d8128316d1f202b61317d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the first param with the given name in the given element.  <br /></td></tr>
<tr class="separator:a5ace76e27d8128316d1f202b61317d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68da53a7019a7c52566e9a2b9506557" id="r_aa68da53a7019a7c52566e9a2b9506557"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68da53a7019a7c52566e9a2b9506557">stumpless_load_element</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:aa68da53a7019a7c52566e9a2b9506557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a provided element with the given name.  <br /></td></tr>
<tr class="separator:aa68da53a7019a7c52566e9a2b9506557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f244f4d91593e5d0db599b9a43019b" id="r_a48f244f4d91593e5d0db599b9a43019b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48f244f4d91593e5d0db599b9a43019b">stumpless_new_element</a> (const char *name)</td></tr>
<tr class="memdesc:a48f244f4d91593e5d0db599b9a43019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element with the given name.  <br /></td></tr>
<tr class="separator:a48f244f4d91593e5d0db599b9a43019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d508289a94ae629a268e709a761443" id="r_ab2d508289a94ae629a268e709a761443"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d508289a94ae629a268e709a761443">stumpless_set_element_name</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name)</td></tr>
<tr class="memdesc:ab2d508289a94ae629a268e709a761443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the given element.  <br /></td></tr>
<tr class="separator:ab2d508289a94ae629a268e709a761443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b053bd1233da7fe6f4205007886b14" id="r_a70b053bd1233da7fe6f4205007886b14"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b053bd1233da7fe6f4205007886b14">stumpless_set_param</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, size_t index, struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *param)</td></tr>
<tr class="memdesc:a70b053bd1233da7fe6f4205007886b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the param at the given index in the given element.  <br /></td></tr>
<tr class="separator:a70b053bd1233da7fe6f4205007886b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddc949f75a370cd8984f12234c1dd67" id="r_a7ddc949f75a370cd8984f12234c1dd67"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ddc949f75a370cd8984f12234c1dd67">stumpless_set_param_value_by_index</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, size_t index, const char *value)</td></tr>
<tr class="memdesc:a7ddc949f75a370cd8984f12234c1dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the param at the given index in the given element.  <br /></td></tr>
<tr class="separator:a7ddc949f75a370cd8984f12234c1dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d9e16dd268df07e1de80d1ed19e95" id="r_a054d9e16dd268df07e1de80d1ed19e95"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054d9e16dd268df07e1de80d1ed19e95">stumpless_set_param_value_by_name</a> (struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element, const char *name, const char *value)</td></tr>
<tr class="memdesc:a054d9e16dd268df07e1de80d1ed19e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the first param with the given name in the given element.  <br /></td></tr>
<tr class="separator:a054d9e16dd268df07e1de80d1ed19e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c8c935bc5a772ad9ac8db8729b638" id="r_aec6c8c935bc5a772ad9ac8db8729b638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec6c8c935bc5a772ad9ac8db8729b638">stumpless_unload_element_and_contents</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *e)</td></tr>
<tr class="memdesc:aec6c8c935bc5a772ad9ac8db8729b638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads an element as well as all params that it contains.  <br /></td></tr>
<tr class="separator:aec6c8c935bc5a772ad9ac8db8729b638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b65689f3a2c6ed3168aa1cc03fdc6d3" id="r_a2b65689f3a2c6ed3168aa1cc03fdc6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b65689f3a2c6ed3168aa1cc03fdc6d3">stumpless_unload_element_only</a> (const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *element)</td></tr>
<tr class="memdesc:a2b65689f3a2c6ed3168aa1cc03fdc6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads an element, freeing any allocated memory.  <br /></td></tr>
<tr class="separator:a2b65689f3a2c6ed3168aa1cc03fdc6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Types and functions for creating and modifying elements. </p>
</div><h2 class="groupheader">宏定义说明</h2>
<a id="ada5fad826965fa8577e97395a2513ffd" name="ada5fad826965fa8577e97395a2513ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5fad826965fa8577e97395a2513ffd">&#9670;&#160;</a></span>STUMPLESS_MAX_ELEMENT_NAME_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUMPLESS_MAX_ELEMENT_NAME_LENGTH&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum length of an element name, as specified by RFC 5424. </p>

</div>
</div>
<h2 class="groupheader">类型定义说明</h2>
<a id="ac610c390facaa0990cae26ed645cf82e" name="ac610c390facaa0990cae26ed645cf82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac610c390facaa0990cae26ed645cf82e">&#9670;&#160;</a></span>stumpless_element_namer_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* stumpless_element_namer_func_t) (const struct <a class="el" href="structstumpless__entry.html">stumpless_entry</a> *entry, size_t element_index, char *destination, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name to use for the journald field corresponding to this element. </p>
<p>If the destination buffer is too small to hold the complete name, then nothing should be done. Callers must be able to detect this by comparing the return value to the value provided in the size argument. If the return value is larger, then the name was not written into destination.</p>
<p><b>Thread Safety: MT-Unsafe</b> This function need not be thread safe. It will be called when locks are already held on the entry and element in question, and therefore should not use any functions that will attempt to lock any of these as this will result in deadlock.</p>
<p><b>Async Signal Safety: AS-Safe</b> This function must be safe to call from signal handlers.</p>
<p><b>Async Cancel Safety: AC-Safe</b> This function must be safe to call from threads that may be asynchronously cancelled.</p>
<dl class="section since"><dt>自从</dt><dd>release v2.1.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The entry that the param is part of.</td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the element in the entry.</td></tr>
    <tr><td class="paramname">destination</td><td>The buffer to write the name to.</td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of bytes to write to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of bytes needed to write the complete name, not including a NULL terminating character. If this is greater than size, then it signifies that nothing was done. </dd></dl>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="a92b5c4af6341951dad54a9af788e2a14" name="a92b5c4af6341951dad54a9af788e2a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b5c4af6341951dad54a9af788e2a14">&#9670;&#160;</a></span>stumpless_add_new_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_add_new_param </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>param_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new param and adds it to the given element. </p>
<p>This is equivalent to calling <a class="el" href="param_8h.html#af410923c5cac1e644b26c6c848b891c1" title="Creates a new param with the given name and value.">stumpless_new_param()</a> and passing the result directly <a class="el" href="#a36b39498f3b9bd6dd20d49d5fc16a99e" title="Adds a param to an element.">stumpless_add_param()</a>.</p>
<p><b>Thread Safety: MT-Safe race:param_name race:param_value</b> This function is thread safe, of course assuming that the param name and value or not changed by other threads during execution. A mutex is used to coordinate updates to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the new param.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to add the new param to.</td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the new param.</td></tr>
    <tr><td class="paramname">param_value</td><td>The value of the new param.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a36b39498f3b9bd6dd20d49d5fc16a99e" name="a36b39498f3b9bd6dd20d49d5fc16a99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b39498f3b9bd6dd20d49d5fc16a99e">&#9670;&#160;</a></span>stumpless_add_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_add_param </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *</td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a param to an element. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate updates to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to adjust the array of params in the element.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to add the param to.</td></tr>
    <tr><td class="paramname">param</td><td>The param to add to element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="acf6b6d0c8682b7409d494850e990f2b3" name="acf6b6d0c8682b7409d494850e990f2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6b6d0c8682b7409d494850e990f2b3">&#9670;&#160;</a></span>stumpless_copy_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_copy_element </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of an element. </p>
<p>Copies of elements are 'deep' in that the copy also copies each of the params that the original element has, if any. This means that even if the params of the original element are destroyed, the equivalent ones in this element will still be valid.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the copy.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A new element that is a deep copy of the original. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="afde32c8772ca89cce0d3ee638d8ed67b" name="afde32c8772ca89cce0d3ee638d8ed67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde32c8772ca89cce0d3ee638d8ed67b">&#9670;&#160;</a></span>stumpless_destroy_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_element </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for stumpless_destroy_element_and_contents. </p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">弃用</a></b></dt><dd>This function has been deprecated in favor of the more descriptive and deliberate stumpless_destroy_element_and_contents and stumpless_destroy_element_only functions in order to avoid unintentional memory leaks and use-after-free mistakes.</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3293ce2407142a896c6ece0089cac33" name="ab3293ce2407142a896c6ece0089cac33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3293ce2407142a896c6ece0089cac33">&#9670;&#160;</a></span>stumpless_destroy_element_and_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_element_and_contents </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an element as well as all params that it contains, freeing any allocated memory. </p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The element to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26f6e8a9f3dc18d7dbffee19627fa331" name="a26f6e8a9f3dc18d7dbffee19627fa331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f6e8a9f3dc18d7dbffee19627fa331">&#9670;&#160;</a></span>stumpless_destroy_element_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_destroy_element_only </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an element, freeing any allocated memory. </p>
<p>Associated params are left untouched, and must be destroyed separately.</p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96a1a0eaf93f5026f91824ff1292e71f" name="a96a1a0eaf93f5026f91824ff1292e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a1a0eaf93f5026f91824ff1292e71f">&#9670;&#160;</a></span>stumpless_element_has_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stumpless_element_has_param </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the given element has a param with the given name, false otherwise. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0.</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to search for the param.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the param to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if no error is encountered and the param is found. If the param is not found or an error is encountered, then false is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="af76334de05ecec6302acdd2b368c4dda" name="af76334de05ecec6302acdd2b368c4dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76334de05ecec6302acdd2b368c4dda">&#9670;&#160;</a></span>stumpless_element_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stumpless_element_to_string </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns name and params from element as a formatted string. </p>
<p>The character buffer should be freed when no longer is needed by the caller.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v2.2.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to get the name and params from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The formatted string of name or name=[param1,...] if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aa6ad7dc6eb77d8beced2b0ce9462d159" name="aa6ad7dc6eb77d8beced2b0ce9462d159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ad7dc6eb77d8beced2b0ce9462d159">&#9670;&#160;</a></span>stumpless_get_element_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stumpless_get_element_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the given element. </p>
<p>The character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the name and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to get the name from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The name of the element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a0171fc80fbf9f4fa0e7ecae07bf93213" name="a0171fc80fbf9f4fa0e7ecae07bf93213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0171fc80fbf9f4fa0e7ecae07bf93213">&#9670;&#160;</a></span>stumpless_get_param_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> * stumpless_get_param_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the param in the given element at the specified index. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to get the param from.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the param to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The param if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a68a45b3e8de00bf01ae382b30bdc708d" name="a68a45b3e8de00bf01ae382b30bdc708d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a45b3e8de00bf01ae382b30bdc708d">&#9670;&#160;</a></span>stumpless_get_param_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> * stumpless_get_param_by_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first occurrence of a param with the given name in element, if it is found. </p>
<p>Note that an element may contain as many instances of a param as desired according to RFC 5424, and therefore there may be other param instances with the same name. If you simply need a count of params with a given name, then you can use stumpless_get_param_name_count to find this. If you need a reference to any other params, then you must loop through all params in the element using stumpless_get_param_by_index, checking each name.</p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to search.</td></tr>
    <tr><td class="paramname">name</td><td>The param name to search for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The param if it is found in the element, or NULL otherwise. If an error was encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a792f240cdec230073975f0e890a7cd80" name="a792f240cdec230073975f0e890a7cd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792f240cdec230073975f0e890a7cd80">&#9670;&#160;</a></span>stumpless_get_param_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stumpless_get_param_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of params in the given element. </p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to get the param count of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of params element has. If there is an error, zero is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a8fcc1fbe4d13fdcab7d7a16997f99b10" name="a8fcc1fbe4d13fdcab7d7a16997f99b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fcc1fbe4d13fdcab7d7a16997f99b10">&#9670;&#160;</a></span>stumpless_get_param_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stumpless_get_param_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the index of the first occurrence of a param with the given name in the given element. </p>
<p>Note that an element may contain as many instances of a param as desired according to RFC 5424, and therefore there may be other param instances that this function does not recognize. If you simply need a count of params with a given name, then you can use stumpless_get_param_name_count to find this. If you need a reference to any other params, then you must loop through all params in the element using stumpless_get_param_by_index, checking each name.</p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to search for params with the given name.</td></tr>
    <tr><td class="paramname">name</td><td>The name to search params for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The first instance of a param with name in element, if one exists. If there is no such param or an error is encountered, NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a6da1a7539ed5de4453534a56ee47076e" name="a6da1a7539ed5de4453534a56ee47076e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da1a7539ed5de4453534a56ee47076e">&#9670;&#160;</a></span>stumpless_get_param_name_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stumpless_get_param_name_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the param with the given index in this element. </p>
<p>The result character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the name and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to get the param and name from.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the param to get the name from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The name of the param at the given index, if no error is encountered. If an error is encountered, NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ae61ef0406ba4d283baa8b2d7dc324779" name="ae61ef0406ba4d283baa8b2d7dc324779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61ef0406ba4d283baa8b2d7dc324779">&#9670;&#160;</a></span>stumpless_get_param_name_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t stumpless_get_param_name_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives the number of params with the given name found in the given element. </p>
<p>If you need to get an actual reference to any of these params beyond the first one, then you will need to loop through all params in the element using stumpless_get_param_by_index, checking each name.</p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by another thread during execution. A mutex is used to coordinate access to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to search for params.</td></tr>
    <tr><td class="paramname">name</td><td>The name to look for in params.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of params found with the given name in the given element. If an error is encountered, zero is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="ac026aa615608e7de8c72b1d34f966fdc" name="ac026aa615608e7de8c72b1d34f966fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac026aa615608e7de8c72b1d34f966fdc">&#9670;&#160;</a></span>stumpless_get_param_value_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stumpless_get_param_value_by_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the param at the given index in the given element. </p>
<p>The result character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the value and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to retrieve the param and value from.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the param to get the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The value of the param at the given index, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a5ace76e27d8128316d1f202b61317d5b" name="a5ace76e27d8128316d1f202b61317d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ace76e27d8128316d1f202b61317d5b">&#9670;&#160;</a></span>stumpless_get_param_value_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * stumpless_get_param_value_by_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the first param with the given name in the given element. </p>
<p>The result character buffer must be freed by the caller when it is no longer needed to avoid memory leaks.</p>
<p>In versions prior to v2.0.0, the returned pointer was to the internal buffer used to store the value and was not to be modified by the caller. This behavior changed in v2.0.0 in order to avoid thread safety issues.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate the read of the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions to create the result.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<p>If you need to get the value of a param with the given name beyond the first one, then you will need to loop through all params in the element using stumpless_get_param_by_index, checking each name.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to retrieve the param and value from.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the param to get the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The value of the first param with the given name, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aa68da53a7019a7c52566e9a2b9506557" name="aa68da53a7019a7c52566e9a2b9506557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68da53a7019a7c52566e9a2b9506557">&#9670;&#160;</a></span>stumpless_load_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_load_element </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a provided element with the given name. </p>
<p>Does not call any memory allocation routines, and is faster than stumpless_new_element as a result.</p>
<p>An element loaded using this function must be unloaded with stumpless_unload_element when it is no longer needed. Calling stumpless_destroy_element or any function that does (such as stumpless_destroy_entry_and_contents will result in memory corruption).</p>
<p><b>Thread Safety: MT-Safe race:element race:name</b> This function is thread safe, assuming that the element and name are not changed by other threads during execution.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a mutex initialization routine. If STUMPLESS_THREAD_SAFETY_SUPPORTED is not defined, then this function is AS-Safe.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a mutex initialization routine. If STUMPLESS_THREAD_SAFETY_SUPPORTED is not defined, then this function is AC-Safe.</p>
<dl class="section since"><dt>自从</dt><dd>release v2.2.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The struct to load.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pointer to the loaded element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a48f244f4d91593e5d0db599b9a43019b" name="a48f244f4d91593e5d0db599b9a43019b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f244f4d91593e5d0db599b9a43019b">&#9670;&#160;</a></span>stumpless_new_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_new_element </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element with the given name. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe, of course assuming that name is not changed by other threads during execution.</p>
<p><b>Async Signal Safety: AS-Unsafe heap</b> This function is not safe to call from signal handlers due to the use of memory management functions to create the new element.</p>
<p><b>Async Cancel Safety: AC-Unsafe heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of memory management functions.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name of the element. Valid name should have printable ASCII characters expect '=', ']' , '"' and should be 32 characters long</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The created element, if no error is encountered. If an error is encountered, then NULL is returned and an error code set appropriately. </dd></dl>

</div>
</div>
<a id="ab2d508289a94ae629a268e709a761443" name="ab2d508289a94ae629a268e709a761443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d508289a94ae629a268e709a761443">&#9670;&#160;</a></span>stumpless_set_element_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_set_element_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the name of the given element. </p>
<p><b>Thread Safety: MT-Safe race:name</b> This function is thread safe. A mutex is used to coordinate changes to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to set the name of.</td></tr>
    <tr><td class="paramname">name</td><td>The new name of the element. Valid name should have printable ASCII characters expect '=', ']' , '"' and should be 32 characters long</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a70b053bd1233da7fe6f4205007886b14" name="a70b053bd1233da7fe6f4205007886b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b053bd1233da7fe6f4205007886b14">&#9670;&#160;</a></span>stumpless_set_param()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_set_param </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structstumpless__param.html">stumpless_param</a> *</td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the param at the given index in the given element. </p>
<p>The parameter previously at this position will be removed from the element, but it is NOT destroyed by this call. Callers must clean up this param separately.</p>
<p>A param cannot be set at an index position that does not already hold a param. If this is attempted, then a STUMPLESS_INDEX_OUT_OF_BOUNDS error is raised.</p>
<p><b>Thread Safety: MT-Safe</b> This function is thread safe. A mutex is used to coordinate changes to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to set the param on.</td></tr>
    <tr><td class="paramname">index</td><td>The index to set to param.</td></tr>
    <tr><td class="paramname">param</td><td>The param to set at the given index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a7ddc949f75a370cd8984f12234c1dd67" name="a7ddc949f75a370cd8984f12234c1dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddc949f75a370cd8984f12234c1dd67">&#9670;&#160;</a></span>stumpless_set_param_value_by_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_set_param_value_by_index </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the param at the given index in the given element. </p>
<p><b>Thread Safety: MT-Safe race:value</b> This function is thread safe, of course assuming that the value is not changed during execution by another thread. A mutex is used to coordinate changes to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to set the param on.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the param to set the value of.</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set on the param.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="a054d9e16dd268df07e1de80d1ed19e95" name="a054d9e16dd268df07e1de80d1ed19e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054d9e16dd268df07e1de80d1ed19e95">&#9670;&#160;</a></span>stumpless_set_param_value_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> * stumpless_set_param_value_by_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the value of the first param with the given name in the given element. </p>
<p>If a param of the given name is not found in the element, one is created with the supplied name and value and added to the end of the element.</p>
<p>If you need to set the value of a param with this name other than the first one, then you will need to loop through the params using stumpless_get_param_by_index to find the params you want and then set the value using stumpless_set_param_value.</p>
<p><b>Thread Safety: MT-Safe race:name race:value</b> This function is thread safe, of course assuming that the name and value are not changed during execution by another thread.. A mutex is used to coordinate changes to the element with other accesses and modifications.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the use of a non-reentrant lock to coordinate access and the use of memory management functions.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, due to the use of a lock that could be left locked as well as memory management functions.</p>
<dl class="section since"><dt>自从</dt><dd>release v1.6.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to set the param on.</td></tr>
    <tr><td class="paramname">name</td><td>The name of the param to set the value of (or create).</td></tr>
    <tr><td class="paramname">value</td><td>The new value to set on the param..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The modified element, if no error is encountered. If an error is encountered, then NULL is returned and an error code is set appropriately. </dd></dl>

</div>
</div>
<a id="aec6c8c935bc5a772ad9ac8db8729b638" name="aec6c8c935bc5a772ad9ac8db8729b638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6c8c935bc5a772ad9ac8db8729b638">&#9670;&#160;</a></span>stumpless_unload_element_and_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_unload_element_and_contents </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads an element as well as all params that it contains. </p>
<p>Either this function or stumpless_unload_element_only must be used to clean up any element struct previously loaded with stumpless_load_element.</p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="section since"><dt>自从</dt><dd>release v2.2.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The element to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b65689f3a2c6ed3168aa1cc03fdc6d3" name="a2b65689f3a2c6ed3168aa1cc03fdc6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b65689f3a2c6ed3168aa1cc03fdc6d3">&#9670;&#160;</a></span>stumpless_unload_element_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stumpless_unload_element_only </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structstumpless__element.html">stumpless_element</a> *</td>          <td class="paramname"><span class="paramname"><em>element</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads an element, freeing any allocated memory. </p>
<p>Associated params are left untouched, and must be unloaded separately.</p>
<p>Either this function or stumpless_unload_element_and_contents must be used to clean up any element struct previously loaded with stumpless_load_element.</p>
<p><b>Thread Safety: MT-Unsafe</b> This function is not thread safe as it destroys resources that other threads would use if they tried to reference this struct.</p>
<p><b>Async Signal Safety: AS-Unsafe lock heap</b> This function is not safe to call from signal handlers due to the destruction of a lock that may be in use as well as the use of the memory deallocation function to release memory.</p>
<p><b>Async Cancel Safety: AC-Unsafe lock heap</b> This function is not safe to call from threads that may be asynchronously cancelled, as the cleanup of the lock may not be completed, and the memory deallocation function may not be AC-Safe itself.</p>
<dl class="section since"><dt>自从</dt><dd>release v2.2.0</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ba40c74cc7a9b9ece787ff31120c1693.html">stumpless</a></li><li class="navelem"><a class="el" href="element_8h.html">element.h</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
